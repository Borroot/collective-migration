<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>CollectiveMigration</title>
	<style type="text/css">
		body {
			font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue",
				Helvetica, Arial, "Lucida Grande", sans-serif;
			padding: 15px;
			max-width: 600px;
			margin: auto;
		}

		td {
			padding: 10px;
			vertical-align: top;
		}
	</style>


	<script src="./artistoo.js"></script>
	<script>
		"use strict"

		let config = {

			// Grid settings
			ndim: 2,
			field_size: [250, 250],

			// CPM parameters and configuration
			conf: {
				// Basic CPM parameters
				torus: [true, true],						// Should the grid have linked borders?
				seed: 1,							// Seed for random number generation.
				T: 20,								// CPM temperature

				// Constraint parameters.
				// Mostly these have the format of an array in which each element specifies the
				// parameter value for one of the cellkinds on the grid.
				// First value is always cellkind 0 (the background) and is often not used.

				// Adhesion parameters:
				J: [
					[0, 20, 0],
					[20, 0, 20],
					[0, 20, 0]
				],

				// VolumeConstraint parameters
				LAMBDA_V: [0, 50, 100],		// VolumeConstraint importance per cellkind
				V: [0, 500, 250],				// Target volume of each cellkind

				// PerimeterConstraint parameters
				LAMBDA_P: [0, 2, 100],			// PerimeterConstraint importance per cellkind
				P: [0, 340, 50],				// Target perimeter of each cellkind

				// ActivityConstraint parameters
				LAMBDA_ACT: [0, 200, 0],			// ActivityConstraint importance per cellkind
				MAX_ACT: [0, 80, 0],				// Activity memory duration per cellkind
				ACT_MEAN: "geometric"				// Is neighborhood activity computed as a
				// "geometric" or "arithmetic" mean?
			},

			// Simulation setup and configuration: this controls stuff like grid initialization,
			// runtime, and what the output should look like.
			simsettings: {

				// Cells on the grid
				NRCELLS: [100, 0],

				// Runtime etc
				BURNIN: 50,
				RUNTIME: 1000,
				RUNTIME_BROWSER: "Inf",

				// Visualization
				CANVASCOLOR: "eaecef",
				CELLCOLOR: ["000000", "ffc0cb"],
				BORDERCOL: ["ffffff", "ffffff"],
				ACTCOLOR: [false],			// Should pixel activity values be displayed?
				SHOWBORDERS: [true],				// Should cellborders be displayed?
				zoom: 2,							// zoom in on canvas with this factor.

				// Output images
				SAVEIMG: true,						// Should a png image of the grid be saved
				// during the simulation?
				IMGFRAMERATE: 1,					// If so, do this every <IMGFRAMERATE> MCS.
				SAVEPATH: "output/img/CollectiveMigration",	// ... And save the image in this folder.
				EXPNAME: "CollectiveMigration",					// Used for the filename of output images.

				// Output stats etc
				STATSOUT: { browser: false, node: true }, // Should stats be computed?
				LOGRATE: 10							// Output stats every <LOGRATE> MCS.

			}
		}

		let sim, meter
		let gridsize = 3

		function initialize() {
			sim = new CPM.Simulation(config, { initializeGrid: initializeGrid })
			step()
		}


		function step() {
			sim.step()
			if (sim.conf["RUNTIME_BROWSER"] == "Inf" | sim.time + 1 < sim.conf["RUNTIME_BROWSER"]) {
				requestAnimationFrame(step)
				// compute_centroid_data(true)
			}
		}

		/* The following custom method will be added to the simulation object. */
		function initializeGrid() {

			// add the initializer if not already there
			if (!this.helpClasses["gm"]) { this.addGridManipulator() }

			for (let y = 0; y < gridsize; y++) {
				for (let x = 0; x < gridsize; x++) {
					let xcoord = this.C.extents[0] / gridsize * (x + 0.5)
					let ycoord = this.C.extents[1] / gridsize * (y + 0.5)
					this.gm.seedCellAt(2, [parseInt(xcoord), parseInt(ycoord)])
				}
			}
		}

		/* do crazy shit to create the streamplot */

		function compute_wrapped(cell_ids, pixels) {

			let minmax = new Map(cell_ids.map(cell_id => [cell_id, [Infinity, -Infinity, Infinity, -Infinity]]))
			// x min, x max, y min, y max

			for (let [[x, y], cell_id] of pixels) {
				let [xmin, xmax, ymin, ymax] = minmax.get(cell_id)

				xmin = x < xmin ? x : xmin
				xmax = x > xmax ? x : xmax
				ymin = y < ymin ? y : ymin
				ymax = y > ymax ? y : ymax

				minmax.set(cell_id, [xmin, xmax, ymin, ymax])
			}

			const D = 200
			let wrapped = new Map()

			for (let [cell_id, [xmin, xmax, ymin, ymax]] of minmax) {
				let xwrap = false
				let ywrap = false

				if (xmax - xmin > D)
					xwrap = true
				if (ymax - ymin > D)
					ywrap = true

				wrapped.set(cell_id, [xwrap, ywrap])
			}

			return wrapped
		}

		function compute_centroids(cell_ids, pixels, wrapped) {

			let centroids = new Map(cell_ids.map(cell_id => [cell_id, [0, [0, 0]]]))

			for (let [coord, cell_id] of pixels) {
				let [count, sum] = centroids.get(cell_id)
				let newsum = [sum[0] + coord[0], sum[1] + coord[1]]
				centroids.set(cell_id, [count + 1, newsum])
			}

			for (let [cell_id, [count, sum]] of centroids.entries())
				centroids.set(cell_id, [parseInt(sum[0] / count), parseInt(sum[1] / count)])

			return centroids
		}

		function draw_centroids(wrapped, centroids) {

			const canvas = document.getElementsByTagName("canvas").item(0)
			const ctx = canvas.getContext('2d')

			const xscale = canvas.width / config.field_size[0]
			const yscale = canvas.height / config.field_size[1]

			for (let [cell_id, [x, y]] of centroids) {
				ctx.beginPath()
				ctx.arc(x * xscale, y * yscale, 5, 0, 2 * Math.PI)

				if (wrapped.get(cell_id).includes(true))
					ctx.fillStyle = 'red'
				else
					ctx.fillStyle = 'blue'

				ctx.fill()
			}
		}

		function compute_centroid_data(draw) {
			const pixels = Array.from(sim.Cim.grid.pixels())
			const cell_ids = [...new Set(pixels.map(x => x[1]))]

			const wrapped = compute_wrapped(cell_ids, pixels)
			const centroids = compute_centroids(cell_ids, pixels, wrapped)

			if (draw)
				draw_centroids(wrapped, centroids)

			return [wrapped, centroids]
		}

		async function capture() {
			const P = sim.Cim.C.conf.P[1]
			const J = sim.Cim.C.conf.J[2][1]
			const name = `G${gridsize}_P${P}_J${J}`

			// capture the canvas
			let canvas = document.getElementsByTagName('canvas').item(0)
			let a = document.createElement('a')
			a.download = `${name}.png`
			a.href = canvas.toDataURL()

			// write the centroid data
			const [wrapped1, centroids1] = compute_centroid_data(false)
			await new Promise(r => setTimeout(r, 3000)) // sleep
			const [wrapped2, centroids2] = compute_centroid_data(false)

			let text = ''
			for (let [cell_id, [x2, y2]] of centroids2) {
				if (wrapped1.has(cell_id)
					&& wrapped1.get(cell_id).every(e => e === false)
					&& wrapped2.get(cell_id).every(e => e === false)
				) {
					let [x1, y1] = centroids1.get(cell_id)
					text += `${x1},${y1},${x2 - x1},${y2 - y1}\n`
				}
			}

			a.click()

			let b = document.createElement('a')
			b.href = "data:application/octet-stream," + encodeURIComponent(text)
			b.download = `${name}.txt`

			b.click()
		}

		/* The following custom methods are used for control buttons on the html page. */

		function changeGrid(newgridsize) {
			gridsize = newgridsize
			killAllCells()
			sim.initializeGrid()
		}

		function startsim() {
			if (!sim.running) {
				sim.running = true
			}
		}

		function stopsim() {
			sim.running = false
		}

		function seedCell(k) {
			sim.gm.seedCell(k)
		}

		function seedCells(ncells) {
			for (let i = 0; i < ncells; i++) {
				seedCell(1)
			}
		}

		function killAllCells() {
			let cells = Object.keys(sim.C.getStat(CPM.PixelsByCell))
			if (cells.length == 0) return
			for (let cp of sim.C.cellPixels()) {
				sim.C.setpix(cp[0], 0)
			}
			sim.initializeGrid()
		}

	</script>
</head>

<body onload="initialize()">

	<h1> Collective Migration With Obstacles</h1>
	<button onclick="startsim()">start</button>
	<button onclick="stopsim()">stop</button>
	<button onclick="seedCells(1)">seed cell</button>
	<button onclick="seedCells(10)">+10 cells</button>
	<button onclick="seedCells(100)">+100 cells</button>
	<button onclick="killAllCells()">remove all cells</button>
	<br>
	<br>

	<table>
		<tr>
			<td>Framerate</td>
			<td><input type="text" value="1" id="frames" oninput="sim.imgrate=this.value"></td>
		</tr>
		<tr>
			<td>Gridsize</td>
			<td><input type="text" value="3" id="frames" oninput="changeGrid(parseInt(this.value))"></td>
		</tr>
		<tr>
			<td>Perimeter</td>
			<td><input type="text" value="340" id="frames" oninput="sim.Cim.C.conf.P[1]=parseInt(this.value)"></td>
		</tr>
		<tr>
			<td>Adhesion</td>
			<td><input type="text" value="20" id="frames"
					oninput="sim.Cim.C.conf.J[1][2]=sim.Cim.C.conf.J[2][1]=parseInt(this.value)"></td>
		</tr>
	</table>
	<br>

</body>

</html>